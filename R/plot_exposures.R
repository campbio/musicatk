#' @title Displays sample exposures with bar plots
#' 
#' @description The distributions of mutational signatures will be displayed 
#' with bar plots. Samples can be grouped using the \code{annotation} parameter.
#' Various methods of sorting samples from left to right can be chosen using
#' the \code{sort_samples} parameter. 
#'
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool.
#' @param proportional If \code{TRUE}, then the exposures will be normalized
#' to between 0 and 1 by dividing by the total number of counts for each sample.
#' Default \code{FALSE}.
#' @param annotation Sample annotation used to group the subplots. If
#' \code{NULL}, no grouping by annotation will be performed.
#' Default \code{NULL}.
#' @param num_samples Number of sorted samples to plot
#' @param sort_samples This is used to change how samples are sorted in
#' the barplot from left to right. If set to \code{"total"}, then samples
#' will be sorted from those with the highest number of mutation counts to the
#' lowest (regardless of how the parameter \code{"proportional"} is set.
#' If set to \code{"name"}, then samples are sorted by their name with the
#' \code{\link[gtools]{mixedsort}} function. If set to 
#' one or more signature names (e.g. \code{"Signature1"}), then samples will
#' be sorted from those with the highest level of that signature to the lowest.
#' If multiple signatures are supplied then,   
#' Default \code{"total"}.
#' @param threshold Exposures less than this threshold will be set to 0
#' when sorting samples. Only used when \code{sort_samples} is set to the name
#' of one or more signatures. This is most useful when more than one signature
#' is supplied as samples that are set to zero for the first exposure will
#' then be sorted by the levels of the second exposure. Default \code{0.01}.
#' @param same_scale If \code{TRUE}, then all subplots will have the 
#' same scale. Only used when \code{annotation} is supplied. 
#' Default \code{FALSE}.
#' @param label_samples If \code{TRUE}, sample labels will be displayed at
#' the bottom of the plot. Default \code{FALSE}.
#' @param legend If \code{TRUE}, the legend will be displayed.
#' Default \code{TRUE}.
#' @param plotly If \code{TRUE}, the the plot will be made interactive
#' using \code{\link[plotly]{plotly}}. Default \code{FALSE}.
#' @return Generates a ggplot or plotly object
#' @examples
#' result <- readRDS(system.file("testdata", "res_annot.rds",
#' package = "musicatk"))
#' plot_exposure_bar(result, annotation = "Tumor_Subtypes")
#' @export
plot_exposure_bar <- function(result,
                          proportional = FALSE,
                          annotation = NULL,
                          num_samples = NULL,
                          sort_samples = "total",
                          threshold = 0.01,
                          same_scale = FALSE,
                          label_samples = FALSE,
                          legend = TRUE, 
                          plotly = FALSE) {
  
  #palette <- match.arg(palette)
  palette <- "ggplot"
  
  # Retreive exposures. Need to eventually make an S4 getter
  exposures <- result@exposures
  total <- colSums(exposures)

  y_label <- "counts"
  if (isTRUE(proportional)) {
    y_label <- "fractions"
    exposures <- sweep(exposures, 2, colSums(exposures), FUN = "/")
  }
  
  # Convert to long format
  plot_dat <- .pivot_exposures(exposures)

  # Add sample annotation to data frame if supplied
  plot_dat <- .add_annotation_to_df(result, plot_dat, annotation)

  # Define the order of samples in the bar plot
  if (length(sort_samples == 1) && sort_samples == "name") {
    # Sort alphabetically with mixed alphanumeric characters
    o <- gtools::mixedsort(colnames(exposures))
  } else if (length(sort_samples == 1) && sort_samples == "total") {
    # Sorting of samples by counts 
    o <- colnames(exposures)[order(total, decreasing = TRUE)]
  } else {
    # Sorting of samples by counts of specific signature(s)
    if (!all(sort_samples %in% rownames(exposures))) {
      stop("Signature is not present in this result, please choose from: \n",
           paste0(rownames(exposures), collapse = "\n"))
    }
    
    # Apply threshold to signatures if supplied
    temp_exposures <- exposures
    if (!is.null(threshold)) {
      if(!is.numeric(threshold) || !length(threshold) == 1 ||
         threshold < 0) {
        stop("The 'threshold' parameter must be a number greater than 0.")
      }
      temp_exposures[temp_exposures < threshold] <- 0
    }
    
    # Convert to data.frame and recursively order based on each signature
    a <- as.data.frame(t(temp_exposures[sort_samples,,drop = FALSE]))
    ix <- do.call(order, c(a, list(decreasing = TRUE)))
    o <- colnames(temp_exposures)[ix]
    
    # Use levels to set order of the signatures being sorted on
    unused_sigs <- setdiff(rownames(temp_exposures), sort_samples)
    plot_dat$signature <- factor(plot_dat$signature, 
                                 levels = c(unused_sigs, rev(sort_samples)))
  }

  # Get top N samples from ordering
  if(!is.null(num_samples)) {
    if(!is.numeric(num_samples) || length(num_samples) != 1 ||
       num_samples < 1 || num_samples > ncol(exposures)) {
      stop("The parameter 'num_samples', needs to be an integer between 1 ",
           "and the total number of samples in the result: ", ncol(exposures))
    }
  } else {
    num_samples <- ncol(exposures)
  }
  o <- head(o, num_samples)
  plot_dat <- subset(plot_dat, sample %in% o)
  plot_dat$sample <- factor(plot_dat$sample, levels = o)
  
  # Generate ggplot object
  p <- ggplot(plot_dat, aes_string(y = "exposure", x = "sample",
                                     fill = "signature")) + 
      geom_bar(stat = "identity")
  p <- .gg_default_theme(p) + theme(legend.title = element_blank(),
                            axis.text.x = element_text(angle = 45, hjust = 1)) +
      xlab("Samples") + ylab(paste0("Exposure ", y_label)) +
      ggplot2::scale_y_continuous(expand = c(0, 0))
    
  if(!is.null(annotation)) {
    scales <- ifelse(isTRUE(same_scale), "free_x", "free")
    p <- p + ggplot2::facet_wrap(~ annotation, drop = TRUE, scales = scales)  
  }
  
  # Add the ability to create a permanent color palette that is the same
  # no matter what the order of the signatures are
  color_vector <- .discrete_colors(nrow(exposures), palette = palette)
  names(color_vector) <- rownames(exposures)
  p <- p + ggplot2::scale_discrete_manual("fill", values = color_vector)
  
  # Toggle sample labels, legend, plotly
  if (!isTRUE(label_samples)) {
    p <- p + theme(axis.text.x = element_blank(), axis.ticks.x =
                     element_blank())
  }
  if (!isTRUE(legend)) {
    p <- p + theme(legend.position = "none")
  }
  if (isTRUE(plotly)) {
    p <- plotly::ggplotly(p)
  }
  return(p)
}


#' @title Displays sample exposures with box/violin plots
#' 
#' @description The distributions of mutational signatures will be displayed 
#' with box or violin plots (based on the \code{plot_type} parameter).
#' Samples can be grouped by a sample annotation
#' saved in the \code{\linkS4class{musica}} object that was used to generate the
#' \code{\linkS4class{musica_result}} object. Exposures can also be
#' grouped by signature by changing the \code{group_by} parameter.
#' 
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction algorithm. 
#' @param proportional If \code{TRUE}, then the exposures will be normalized
#' to between 0 and 1 by dividing by the total number of counts for each sample.
#' Default \code{FALSE}.
#' @param plot_type Determines the type of plot to display. One of 
#' "violin" or "boxplot". Default \code{violin}.
#' @param annotation Sample annotation used to group the subplots. If
#' \code{NULL}, no grouping by annotation will be performed.
#' Default \code{NULL}. Only used if the \code{group_by} parameter is set.
#' @param group_by Determines how to group the subplots (i.e. facets).
#' One of \code{"none"}, \code{"signature"} or \code{"annotation"}. If set to
#' \code{"annotation"}, then a sample annotation must be supplied via the 
#' \code{annotation} parameter. Default \code{"none"}.
#' @param add_points If \code{TRUE}, then points for individual sample 
#' exposures will be plotted above the violin/box plots. Default \code{TRUE}.
#' @param legend If \code{TRUE}, the legend will be displayed.
#' Default \code{TRUE}.
#' @param plotly If \code{TRUE}, the the plot will be made interactive
#' using \code{\link[plotly]{plotly}}. Default \code{FALSE}.
#' @return Generates a ggplot or plotly object
#' @examples
#' result <- readRDS(system.file("testdata", "res_annot.rds",
#' package = "musicatk"))
#' plot_exposure_box(result, group_by = "annotation", annotation = "Tumor_Subtypes")
#' @export
plot_exposure_box <- function(result, proportional = FALSE,
                              plot_type = c("violin", "box"),
                              annotation = NULL,
                              group_by = c("none", "annotation", "signature"),
                              add_points = TRUE, legend = TRUE,
                              plotly = FALSE) {
  plot_type <- match.arg(plot_type)
  group_by <- match.arg(group_by)
  
  # Retreive exposures. Need to eventually make an S4 getter
  exposures <- result@exposures

  y_label <- "counts"
  if (isTRUE(proportional)) {
    y_label <- "fractions"
    exposures <- sweep(exposures, 2, colSums(exposures), FUN = "/")
  }

  # Convert to long format
  plot_dat <- .pivot_exposures(exposures)
  
  # Add sample annotation to data frame if supplied
  plot_dat <- .add_annotation_to_df(result, plot_dat, annotation)
  
  # Generate ggplot object from 4 configurations of 'group_by' and 'annotation'
  if(group_by == "annotation" & !is.null(annotation)) {
    plot_dat %>%
      ggplot(aes_string(x = "signature",
                        y = "exposure",
                        fill = "signature",
                        text = "annotation")) -> p
    p <- p + ggplot2::facet_wrap(~ annotation, drop = FALSE, scales = "free")  
  } else if (group_by == "annotation" & is.null(annotation)) {
    stop("If parameter 'group_by' is set to 'annotation', then the ",
         "'annotation' parameter must be supplied.")
  } else if (group_by == "signature" & !is.null(annotation)) {
    plot_dat %>%
      ggplot(aes_string(x = "annotation",
                        y = "exposure",
                        fill = "annotation",
                        text = "annotation")) -> p
    p <- p + ggplot2::facet_wrap(~ signature, drop = FALSE, scales = "free")    
  } else {
    plot_dat %>%
      ggplot(aes_string(x = "signature",
                        y = "exposure")) -> p
  }
  
  p <- .gg_default_theme(p) + theme(legend.title = element_blank(),
                                    axis.text.x = element_text(angle = 45,
                                                               hjust = 1))
    
  p <- p + ggplot2::ylab(paste0("Signatures ", y_label)) + ggplot2::xlab("")
  
  # Add box type and points
  if(plot_type == "box") {
    p <- p +  ggplot2::geom_boxplot()
  } else {
    p <- p +  ggplot2::geom_violin(alpha = 0.75)
  }
  if(isTRUE(add_points)) {
    p <- p + ggplot2::geom_point(pch = 21,
                                 position = ggplot2::position_jitterdodge())
  }
  if (!isTRUE(legend)) {
    p <- p + theme(legend.position = "none")
  }
  if (isTRUE(plotly)) {
    p <- plotly::ggplotly(p)
  }
  return(p)  
}


.pivot_exposures <- function(exposures) {
  # Convert to long data frame
  t(exposures) %>%
    as.data.frame %>%
    tibble::rownames_to_column(var = "sample") %>%
    tidyr::pivot_longer(cols = rownames(exposures),
                        names_to = "signature",
                        values_to = "exposure",
                        names_repair = "minimal") -> temp
  return(temp)
}

.add_annotation_to_df <- function(result, plot_dat, annotation = NULL) {
  # Add sample annotation to data frame if supplied
  if(!is.null(annotation)) {
    
    # Need to replace with S4 getter
    sample_annot <- result@musica@sample_annotations
    
    if(!annotation %in% colnames(sample_annot)) {
      stop("'", annotation, "' was not found in sample annotations in the ",
           "'musica' object. Current annotations are: ",
           paste(colnames(sample_annot), collapse = ", "))
    }
    selected_annot <- sample_annot[[annotation]]
    
    names(selected_annot) <- sample_annot$Samples
    plot_dat$annotation <- selected_annot[plot_dat$sample]
  } else {
    plot_dat$annotation <- "none"
  }
  return(plot_dat)
}
