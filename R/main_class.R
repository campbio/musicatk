#' @importFrom utils capture.output
NULL

# Count Tables object/methods -------------------------------

#' Object containing the count table matrices, their names and descriptions
#' that we generated by provided and by user functions. These are used to
#' discover and infer signatures and exposures.
#'
#' @slot name A name that describes the type of table (e.g. "SBS96")
#' @slot count_table An array of counts with samples as the columns and motifs
#' as the rows
#' @slot annotation A data.frame of annotations with three columns used for
#' plotting: motif, mutation, and context
#' @slot features Original features used to generate the count_table
#' @slot type The mutation type of each feature, in case we need to plot or
#' model they differently
#' @slot color_variable The variable used for plotting colors, selected from
#' the annotation slot
#' @slot color_mapping The mapping of the annotations chosen by color_variable
#' to color values for plotting
#' @slot description A summary table of the result objects in result_list
#' a list of lists. The nested lists created combined (rbind) tables, and the
#' tables at the first list level are modelled independantly. Combined tables
#' must be named.
#' list("tableA", comboTable = list("tableC", "tableD"))
#' @importFrom S4Vectors Rle
#' @export
setClass("count_table", slots = c(name = "character",
                                  count_table = "array",
                                  annotation = "data.frame",
                                  features = "data.frame",
                                  type = "Rle",
                                  color_variable = "character",
                                  color_mapping = "character",
                                  description = "character"))

setMethod("show", "count_table",
          function(object)    cat("Count_Table: ", object@name,
                                  c("\nMotifs:", dim(object@count_table)[1], 
                                    "\nSamples:", dim(object@count_table)[2], 
                                    "\n"),
                                    "\n**Annotations: \n",
                                    paste(capture.output(rbind(head(
                                      object@annotation), "...")), 
                                      collapse = "\n"),
                                    "\n\n**Features: \n",
                                    paste(capture.output(rbind(head(
                                      object@features), "...")), 
                                      collapse = "\n"),
                                    "\n\n**Types: \n",
                                    paste0(unique(object@type), "\n"),
                                    "\n**Color Variable: \n",
                                    paste0(object@color_variable, "\n"),
                                    "\n**Color Mapping: \n",
                                    paste0(object@color_mapping, "\n"),
                                    "\n**Descriptions: \n",
                                    paste0(object@description, "\n"))
          )

# Primary variant object/methods -------------------------------

#' The primary object that contains variants, count_tables,
#' and samples annotations
#'
#' @slot variants \code{data.table} of variants
#' @slot count_tables Summary table with per-sample unnormalized motif counts
#' @slot sample_annotations Sample-level annotations (e.g. age, sex, primary)
#' @export
#' @exportClass musica
setClass("musica", slots = c(variants = "data.table",
                                 count_tables = "list",
                                 sample_annotations = "data.table"),
         prototype = list(variants = data.table::data.table(),
                   count_tables = list(),
                   sample_annotations = data.table::data.table()))

# setMethod("show", "musica_variants",
#           function(object)cat(cat("musica object containing \n**Variants: \n"),
#                               if (!all(is.na(object@variants))) {
#                                 cat(methods::show(object@variants))
#                                 }else{
#                                   cat("Empty")
#                                     },
#                               cat("\n**Count_Tables Object containing: \n"),
#                               if (length(object@count_tables@table_name) > 0) {
#                                 cat("\n**Count Tables: \n",
#                                     apply(cbind(do.call("rbind", lapply(
#                                       object@count_tables@table_list, dim)),
#                                       "\n"), 1, paste),
#                                     "\n**Names: \n", paste(
#                                         unlist(object@count_tables@table_name),
#                                         "\n", sep = ""), "\n**Descriptions: \n",
#                                     paste(unlist(
#                                       object@count_tables@description), "\n",
#                                       sep = ""))
#                                 }else{
#                                   cat("Empty")
#                                   },
#                               cat("\n**Sample Level Annotations: \n"),
#                               if (!all(is.na(object@sample_annotations))) {
#                                 cat(methods::show(object@sample_annotations))
#                               }else{
#                                 cat("Empty")
#                               })
# )

# Variant-Level object/methods -------------------------------

#' Return sample from musica_variant object
#'
#' @param musica A \code{\linkS4class{musica}} object.
#' @param sample_name Sample name to subset by
#' @return Returns sample data.frame subset to a single sample
#' @examples
#' musica <- readRDS(system.file("testdata", "musica.rds", package = "musicatk"))
#' subset_variants_by_samples(musica, "public_LUAD_TCGA-97-7938.vcf")
#' @export
subset_variants_by_samples <- function(musica, sample_name) {
  return(musica@variants[which(musica@variants$sample == sample_name),
                      ])
}

# Sample-Level object/methods -------------------------------

#' Set sample level annotations for musica object
#'
#' @param musica A \code{\linkS4class{musica}} object.
#' @param annotations Sample DataFrame
#' @return Sets sample_annotations slot {no return}
#' @examples
#' musica <- readRDS(system.file("testdata", "musica_sbs96.rds", package = "musicatk"))
#' sample_annotations <- read.table(system.file("testdata",
#' "sample_annotations.txt", package = "musicatk"), sep = "\t", header=TRUE)
#' set_sample_annotations(musica, data.table::data.table(sample_annotations))
#' @export
set_sample_annotations <- function(musica, annotations) {
  eval.parent(substitute(musica@sample_annotations <- annotations))
}

#' Initialize sample annotation data.table with sample names from variants
#'
#' @param musica A \code{\linkS4class{musica}} object.
#' @return Sets sample_annotations slot {no return}
#' @examples
#' musica <- readRDS(system.file("testdata", "musica_sbs96.rds", package = "musicatk"))
#' init_sample_annotations(musica)
#' @export
init_sample_annotations <- function(musica) {
  #samples <- unique(tools::file_path_sans_ext(
  #  musica@variants$Tumor_Sample_Barcode))
  samples <- unique(musica@variants$sample)
  sample_dt <- data.table::data.table(Samples = samples)
  eval.parent(substitute(musica@sample_annotations <- sample_dt))
}

#' Adds sample annotation to musica object with available samples
#' 
#' @param musica A \code{\linkS4class{musica}} object.
#' @param annotations table of sample-level annotations to add
#' @param sample_column name of sample name column
#' @param columns_to_add which annotation columns to add, defaults to all
#' @return Sets sample_annotations slot {no return}
#' @examples
#' musica <- readRDS(system.file("testdata", "musica_sbs96.rds", package = "musicatk"))
#' init_sample_annotations(musica)
#' sample_annotations <- read.table(system.file("testdata",
#' "sample_annotations.txt", package = "musicatk"), sep = "\t", header=TRUE)
#' add_sample_annotations(musica = musica, annotations = sample_annotations,
#' sample_column = "Sample_Names", columns_to_add = "Tumor_Subtypes")
#' musica
#' @export
add_sample_annotations <- function(musica, annotations, sample_column =
                                     "Sample_ID", columns_to_add =
                                     colnames(annotations)) {
  musica_annotations <- get_sample_annotations(musica)
  if (all(is.na(musica_annotations))) {
    stop(strwrap(prefix = " ", initial = "", "Please run init_sample_annotations
                 on this musica object before adding sample annotations."))
  }
  if (!sample_column %in% colnames(annotations)) {
    stop(strwrap(prefix = " ", initial = "", "User-defined sample_column is
                 not in input annotations, please check and rerun."))
  }
  if (!all(musica_annotations$Samples %in%
          annotations[, sample_column])) {
    stop(strwrap(prefix = " ", initial = "", "Some samples are missing
                 annotations, please check input annotations and rerun."))
  }
  if (!all(columns_to_add %in% colnames(annotations))) {
    stop(strwrap(prefix = " ", initial = "", paste("Some user-defined
                                                   columns_to_add are not in
                                                   the input annotations, (",
                 toString(columns_to_add[which(!columns_to_add %in%
                                        colnames(annotations))]),
                 ") please check and rerun.", sep = "")))
  }
  matches <- match(musica_annotations$Samples,
                  annotations[, sample_column])
  musica_annotations <- cbind(musica_annotations, annotations[matches, columns_to_add,
                                                       drop = FALSE])
  eval.parent(substitute(musica@sample_annotations <- musica_annotations))
}

#' Return sample annotation from musica object
#'
#' @param musica A \code{\linkS4class{musica}} object.
#' @return Sets sample_annotations slot {no return}
#' @examples
#' musica <- readRDS(system.file("testdata", "musica.rds", package = "musicatk"))
#' init_sample_annotations(musica)
#' get_sample_annotations(musica)
#' @export
get_sample_annotations <- function(musica) {
  return(musica@sample_annotations)
}

#' Return samples names for musica object
#'
#' @param musica A \code{\linkS4class{musica}} object.
#' @return Returns names of samples in musica object
#' @examples
#' musica <- readRDS(system.file("testdata", "musica.rds", package = "musicatk"))
#' get_sample_names(musica)
#' @export
get_sample_names <- function(musica) {
  return(unique(musica@variants$sample))
}

#' Return variants for musica object
#'
#' @param musica A \code{\linkS4class{musica}} object.
#' @return Returns variants in musica object
#' @examples
#' musica <- readRDS(system.file("testdata", "musica.rds", package = "musicatk"))
#' get_variants(musica)
#' @export
get_variants <- function(musica) {
  return(musica@variants)
}

#' Creates a new musica subsetted to only samples with enough variants
#'
#' @param musica A \code{\linkS4class{musica}} object.
#' @param table_name Name of table used for subsetting
#' @param num_counts Minimum sum count value to drop samples
#' @return Returns a new musica object with sample annotations, count tables,
#' and variants subsetted to only contains samples with the specified minimum
#' number of counts (column sums) in the specified table
#' @examples
#' musica <- readRDS(system.file("testdata", "musica_sbs96.rds", package = "musicatk"))
#' subset_musica_by_counts(musica, "SBS96", 20)
#' @export
subset_musica_by_counts <- function(musica, table_name, num_counts) {
  tab <- .extract_count_table(musica, table_name)
  min_samples <- colnames(tab)[which(colSums(tab) >= num_counts)]

  musica@count_tables <- subset_count_tables(musica, min_samples)

  #Subset variants
  musica@variants <- musica@variants[which(musica@variants$Tumor_Sample_Barcode %in%
                                      min_samples), ]

  #Subset sample annotations
  if (nrow(musica@sample_annotations) != 0) {
    musica@sample_annotations <- musica@sample_annotations[which(
      musica@sample_annotations$Samples %in% min_samples), ]
  }
  return(musica)
}

#' Creates a new musica object subsetted to only one value of a sample annotation
#'
#' @param musica A \code{\linkS4class{musica}} object.
#' @param annot_col Annotation class to use for subsetting
#' @param annot_names Annotational value to subset to
#' @return Returns a new musica object with sample annotations, count tables,
#' and variants subsetted to only contains samples of the specified annotation
#' type
#' @examples
#' musica <- readRDS(system.file("testdata", "musica_sbs96.rds", package = "musicatk"))
#' sample_annotations <- read.table(system.file("testdata",
#' "sample_annotations.txt", package = "musicatk"), sep = "\t", header=TRUE)
#' init_sample_annotations(musica)
#' add_sample_annotations(musica, sample_annotations, sample_column =
#' "Sample_Names", columns_to_add = "Tumor_Subtypes")
#' subset_musica_by_annotation(musica, "Tumor_Subtypes", "Lung")
#' @export
subset_musica_by_annotation <- function(musica, annot_col, annot_names) {
  if (!all(annot_col %in% colnames(musica@sample_annotations))) {
    stop(paste(annot_col, " not found in annotation columns, please review.",
               sep = ""))
  }
  annotation_index <- which(musica@sample_annotations[[which(colnames(
    musica@sample_annotations) %in% annot_col)]] %in% annot_names)
  if (length(annotation_index) == 0) {
    stop(paste(annot_names, " not present in ", annot_col,
               " column, please review.", sep = "", collapse = TRUE))
  }
  musica@sample_annotations <- musica@sample_annotations[annotation_index, ]
  annotation_samples <- musica@sample_annotations$"Samples"
  musica@count_tables <- subset_count_tables(musica, annotation_samples)
  musica@variants <- musica@variants[which(musica@variants$Tumor_Sample_Barcode %in%
                                      annotation_samples), ]
  return(musica)
}

drop_na_variants <- function(variants, annot_col) {
  if (!annot_col %in% colnames(variants)) {
    stop(paste(annot_col, " not found in annotation columns, please review.",
               sep = ""))
  }
  if (length(which(variants[[annot_col]] == "NA")) == 0) {
    return(variants)
  } else {
    return(variants[-which(variants[[annot_col]] == "NA"), ])
  }
}

# Result object/methods -------------------------------

#' Object containing deconvolved/predicted signatures, sample weights, and
#' the musica object the result was generated from
#'
#' @slot signatures A matrix of signatures by mutational motifs
#' @slot exposures A matrix of samples by signature weights
#' @slot tables A character vector of table names used to make the result
#' @slot type Describes how the signatures/weights were generated
#' @slot musica The musica object the results were generated from
#' @slot log_lik Posterior likelihood of the result (LDA only)
#' @slot perplexity Metric of goodness of model fit
#' @slot umap List of umap data.frames for plotting and analysis
#' @export
#' @exportClass musica_result
setClass("musica_result", representation(signatures = "matrix", exposures = "matrix",
                                  tables = "character",
                                  type = "character", musica = "musica",
                                  log_lik = "numeric", perplexity = "numeric",
                                  umap = "list"))

#' Return sample from musica object
#'
#' @param result Result object containing signatures and weights
#' @param name_vector Vector of user-defined signature names
#' @return Result object with user-defined signatures names
#' @examples
#' result <- readRDS(system.file("testdata", "res.rds", package = "musicatk"))
#' name_signatures(result, c("smoking", "apobec", "unknown"))
#' @export
name_signatures <- function(result, name_vector) {
  num_sigs <- length(colnames(result@signatures))
  if (length(name_vector) != num_sigs) {
    stop(paste("Please provide a full list of signatures names (length = ",
               num_sigs, ")", sep = ""))
  }
  eval.parent(substitute(colnames(result@signatures) <- name_vector))
  eval.parent(substitute(rownames(result@exposures) <- name_vector))
}

# Result Grid object/methods -------------------------------

#' Object containing the result objects generated from the combination of
#' annotations and a range of k values
#'
#' @slot grid_params The parameters the result grid was created using
#' @slot result_list A list of result objects with different parameters
#' @slot grid_table A summary table of the result objects in result_list
#' @export
setClass("musica_result_grid", representation(grid_params = "data.table",
                                       result_list = "list",
                                       grid_table = "data.table"))
