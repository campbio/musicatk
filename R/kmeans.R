#' @title Perform k-means clustering from a musica result object
#' @description Proportional sample exposures will be used as input to perform clustering.
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool.
#' @param nclust Pre-defined number of clusters.
#' @param method Clustering algorithms. Options are "kmeans" (K-means), "hkmeans" (hybrid of hierarchical 
#' K-means), "hclust" (hierarchical clustering), "pam" (PAM), and "clara" (Clara).
#' @param iter.max Maximum number of iterations. Default is 10.
#' @param clara.samples Number of samples to be drawn from dataset. Only used when "clara" is selected. 
#' Default is 5.
#' @return A one-column data frame with sample IDs as row names and cluster number for each sample.
#' @seealso \link[stats]{kmeans}
#' @examples 
#' set.seed(123)
#' data(res_annot)
#' clust_out <- cluster_exposure(res_annot, nclust = 2)
#' @export

cluster_exposure <- function(result, nclust, method = "kmeans", iter.max = 10, clara.samples = 5){
  method <- match.arg(method, c("kmeans", "hkmeans", "hclust", "pam", "clara"))
  expos <- exposures(result = result)
  expos <- t(sweep(expos, 2, colSums(expos), FUN = "/"))
  if(method == "kmeans"){
    k_res <- stats::kmeans(x = expos, centers = nclust, iter.max = iter.max)
    clust_out <- data.frame(cluster = factor(unname(k_res$cluster)))
    rownames(clust_out) <- names(k_res$cluster)
  }
  else if(method == "hkmeans"){
    res <- factoextra::hkmeans(x = expos, k = nclust, iter.max = iter.max)
    clust_out <- data.frame(cluster = res$cluster)
  }
  else if(method == "hclust"){
    res <- factoextra::hcut(x = expos, k = nclust, isdiss = FALSE)
    clust_out <-data.frame(cluster = res$cluster)
  }
  else if(method == "pam"){
    clust_out <- data.frame(cluster = cluster::pam(x = expos, k = nclust,
                                                   diss = FALSE,
                                                   cluster.only = TRUE))
  }
  else{
    res <- cluster::clara(x = expos, k = nclust, samples = clara.samples)
    clust_out <- data.frame(cluster = res$clustering)
  }
  return(clust_out)
}

#' @title Visualize clustering results
#' @description The clustering results can be visualized on a UMAP panel. 
#' Three different types of plots can be generated using this function: cluster-by-signature 
#' plot, cluster-by-annotation plot, and a single UMAP plot.
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool. A two-dimensional UMAP has to
#' be stored in this object.
#' @param clusters The result generated from cluster_exposure function.
#' @param group A single character string indicating the grouping factor. 
#' Possible options are: "signature" (columns are signatures in a grid), 
#' "annotation" (columns are sample annotation), and "none" (a single UMAP plot). 
#' Default is "signature".
#' @param annotation Column name of annotation.
#' @return Generate a ggplot object.
#' @seealso \link{create_umap}
#' @examples 
#' set.seed(123)
#' data(res_annot)
#' #Get clustering result
#' clust_out <- cluster_exposure(result = res_annot, nclust = 2)
#' #UMAP
#' create_umap(result = res_annot)
#' #generate cluster X signature plot
#' plot_kmeans(result = res_annot, clusters = clust_out, group = "signature")
#' #generate cluster X annotation plot
#' plot_kmeans(result = res_annot, clusters = clust_out, group = "annotation",
#'             annotation = "Tumor_Subtypes")
#' #generate a single UMAP plot
#' plot_kmeans(result = res_annot, clusters = clust_out, group = "none")
#' @export

plot_kmeans <- function(result, clusters, group = "signature", annotation = NULL){
  group <- match.arg(group, c("signature", "annotation", "none"))
  if(length(umap(result)) == 0){
    stop("UMAP not found in musica_result object. Run create_umap(", deparse(substitute(result)),") first.")
  }
  k_toplot <- cbind(result@umap, clusters)
  if(group == "signature"){
    expos <- exposures(result = result)
    expos <- t(sweep(expos, 2, colSums(expos), FUN = "/"))
    clust_by_sigs <- cbind(k_toplot, expos) %>%
      tibble::rownames_to_column(var = "sample") %>%
      tidyr::pivot_longer(cols = colnames(expos),
                          names_to = "signature",
                          values_to = "exposure",
                          names_repair = "minimal")
    ggplot2::ggplot(clust_by_sigs, aes_string(x = "UMAP_1", y = "UMAP_2", colour = "exposure")) +
      geom_point() +
      facet_grid(cluster ~ signature) +
      ggplot2::scale_colour_gradientn(colors = c("blue", "green", "yellow", "orange", "red"), name = "Fraction")
  }
  else if(group == "annotation"){
    if(is.null(annotation) || !annotation %in% colnames(samp_annot(result))){
      stop("Sample annotation not found or invalid annotation column name.")
    }
    else{
      annot <- samp_annot(result) %>% tibble::column_to_rownames(var = "Samples")
      colnames(annot) <- "annotation"
      annot[["annotation"]] <- factor(annot[["annotation"]])
      clust_by_annot <- cbind(k_toplot, annot)
      ggplot2::ggplot(clust_by_annot, aes_string(x = "UMAP_1", y = "UMAP_2", colour = "cluster")) +
        geom_point() +
        facet_grid(cluster ~ annotation)
    }
  }
  else{
    ggplot2::ggplot(k_toplot, aes_string(x = "UMAP_1", y = "UMAP_2", colour = "cluster")) +
      geom_point()
  }
}

#' @title Plots for helping decide number of clusters for k-means
#' @description To help decide the number of cluster for k-means, three different methods 
#' are provided: total within cluster sum of squares, average silhouette coefficient, 
#' and gap statistics.
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool.
#' @param method A single character string indicating which statistic to use for plot. 
#' Options are "elbow" (total within cluster sum of squares), "silhouette" (average silhouette 
#' coefficient), and "gap" (gap statistic). Default is "elbow".
#' @param n An integer indicating maximum number of clusters to test. Default is 10.
#' @return A ggplot object.
#' @seealso \link[factoextra]{fviz_nbclust}
#' @examples 
#' data(res_annot)
#' #Make an elbow plot
#' withr::with_seed(123, k_select(res_annot, method = "elbow", n = 6))
#' #Plot average silhouette coefficient against number of clusters
#' withr::with_seed(123, k_select(res_annot, method = "silhouette", n = 6))
#' #Plot gap statistics against number of clusters
#' withr::with_seed(123, k_select(res_annot, method = "gap", n =6))
#' @export

k_select <- function(result, method = c('elbow', 'silhouette', 'gap'), n = 10){
  method <- match.arg(method, c("elbow", "silhouette", "gap"))
  expos <- exposures(result = result)
  expos <- t(sweep(expos, 2, colSums(expos), FUN = "/"))
  if(method == "elbow"){
    factoextra::fviz_nbclust(expos, kmeans, method = "wss", k.max = n)
  }
  else if(method == "silhouette"){
    factoextra::fviz_nbclust(expos, kmeans, method = "silhouette", k.max = n)
  }
  else{
    factoextra::fviz_nbclust(expos, kmeans, method = "gap_stat", k.max = n)
  }
}
