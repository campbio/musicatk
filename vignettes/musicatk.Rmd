---
title: "Mutational Signature Comprehensive Analysis Toolkit"
author:
- name: Aaron Chevalier
  affiliation: &id Boston University School of Medicine
- name: Joshua Campbell
  affiliation: *id
  email: camp@bu.edu
output:
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Mutational Signature Comprehensive Analysis Toolkit}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE, results = "asis"}
BiocStyle::markdown()
knitr::opts_chunk$set(echo = TRUE, dev = "png")
```

# Introduction
A variety of exogenous exposures or endogenous biological processes can contribute to the overall mutational load observed in human tumors. Many different mutational patterns, or “mutational signatures”, have been identified across different tumor types. These signatures can provide a record of environmental exposure and can give clues about the etiology of carcinogenesis. The Mutational Signature TookKit has utilities for extracting variants from a variety of file formats, contains multiple methods for discovery of novel signatures or prediction of known signatures, as well as many types of downstream visualizations for exploratory analysis. This package has the ability to parse and combine multiple motif classes in the mutational signature discovery or prediction processes. Mutation motifs include single base substitutions (SBS), double base substitutions (DBS), insertions (INS) and deletions (DEL).

# Installation
Currently musicatk can be installed from on Bioconductor using the following code:

```{r, eval= FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE)){
    install.packages("BiocManager")}
BiocManager::install("musicatk")
```

To install the latest version from Github, use the following code:

```{r, eval = FALSE}
library(devtools)
install_github("campbio/musicatk")
```

The package can be loaded using the `library` command.

```{r, eval = TRUE, message = FALSE}
library(musicatk)
```

# Setting up a musica object
In order to discover or predict mutational signatures, we must first set up
our musica object by 1) extracting variants from files or objects such as
VCFs and MAFs, 2) selecting the appropriate reference genome 3) creating a musica object, and 4) building a count tables for our varinats of interest.

## Extracting variants
Variants can be extracted from various formats using the following functions:

* The `extract_variants_from_vcf_file()` function will extract variants from a [VCF](https://samtools.github.io/hts-specs/) file. The file will be imported using the readVcf function from the [VariantAnnotation](https://bioconductor.org/packages/release/bioc/html/VariantAnnotation.html) package and then the variant information will be extracted from this object.
* The `extract_variants_from_vcf()` function extracts variants from a `CollapsedVCF` or `ExpandedVCF` object from the [VariantAnnotation](https://bioconductor.org/packages/release/bioc/html/VariantAnnotation.html) package.
* The `extract_variants_from_maf_file()` function will extract variants from a file in [Mutation Annotation Format (MAF)](https://docs.gdc.cancer.gov/Data/File_Formats/MAF_Format/) used by TCGA.
* The `extract_variants_from_maf()` function will extract variants from a MAF object created by the [maftools](https://www.bioconductor.org/packages/release/bioc/html/maftools.html) package. 
* The `extract_variants_from_matrix()` function will get the information from a matrix or data.frame like object that has columns for the chromosome, start position, end position, reference allele,  mutation allele, and sample name. 
* The `extract_variants()` function will extract variants from a list of objects. These objects can be any combination of VCF files, VariantAnnotation objects, MAF files, MAF objects, and data.frame objects.

Below are some examples of extracting variants from MAF and VCF files:

```{r extract_variants, message = FALSE}
# Extract variants from a MAF File
lusc_maf <- system.file("extdata", "public_TCGA.LUSC.maf", package = "musicatk") 
lusc.variants <- extract_variants_from_maf_file(maf_file = lusc_maf)

# Extract variants from an individual VCF file
luad_vcf <- system.file("extdata", "public_LUAD_TCGA-97-7938.vcf", 
                         package = "musicatk")
luad.variants <- extract_variants_from_vcf_file(vcf_file = luad_vcf)

# Extract variants from multiple files and/or objects
melanoma_vcfs <- list.files(system.file("extdata", package = "musicatk"), 
                           pattern = glob2rx("*SKCM*vcf"), full.names = TRUE)
variants <- extract_variants(c(lusc_maf, luad_vcf, melanoma_vcfs))
```

## Choosing a genome
musicatk uses [BSgenome](https://bioconductor.org/packages/release/bioc/html/BSgenome.html) objects to access genome sequence information that flanks each mutation which is used bases for generating mutation count tables. BSgenome objects store full genome sequences for different organisms. A full list of supported organisms can be obtained by running `available.genomes()`. Custom genomes can be forged as well (see [BSgenome](https://bioconductor.org/packages/release/bioc/html/BSgenome.html) documentation). musicatk provides a utility function called `select_genome()` to allow users to quickly select human genome build versions "hg19" and "hg38" or mouse genome builds "mm9" and "mm10". The reference sequencing for these genomes are in UCSC format (e.g. chr1).

```{r select_genome}
g <- select_genome("hg38")
```

## Creating a musica object
The last preprocessing step is to create an object with the variants and the genome. This function will perform checks to ensure that the chromosome names and reference alleles in the input variant object match those in supplied BSgenome object. These checks can be turned off by setting `check_ref_chromosomes = FALSE` and `check_ref_bases = FALSE`, respectively.

```{r create_musica}
musica <- create_musica(x = variants, genome = g)
```

# Creating mutation count tables
Motifs are the building blocks of mutational signatures. Motifs themselves are 
a mutation combined with other genomic information. For instance, **SBS96** 
motifs are constructed from an SBS mutation and one upsteam and one downstream 
base sandwiched together. We build tables by counting these motifs for each 
sample. 
```{r build_tables}
build_standard_table(musica, g = g, table_name = "SBS96")
```

Here is a list of mutation tables that can be created:

* SBS96 - Motifs are the six possible single base pair mutation types times the 
four possibilities each for upstream and downstream context bases (4*6*4 = 96 
motifs)
* SBS192_Trans - Motifs are an extension of SBS96 multiplied by the 
transcriptional strand (translated/untranslated), can be specified with 
`"Transcript_Strand"`.
* SBS192_Rep - Motifs are an extension of SBS96 multiplied by the 
replication strand (leading/lagging), can be specified with 
`"Replication_Strand"`.
* DBS - Motifs are the 78 possible double-base-pair substitutions 
* INDEL - Motifs are 83 categories intended to capture different categories of 
indels based on base-pair change, repeats, or microhomology, insertion or 
deletion, and length.

```{r combine_tables}
data(dbs_musica)
build_standard_table(dbs_musica, g, "SBS96")
build_standard_table(dbs_musica, g, "DBS")

#Subset SBS table to DBS samples so they cam be combined
count_tables <- tables(dbs_musica)
overlap_samples <- which(colnames(count_tables$SBS96@count_table) %in%
                           colnames(count_tables$DBS@count_table))
count_tables$SBS96@count_table <- count_tables$SBS96@count_table[, overlap_samples]
tables(dbs_musica) <- count_tables

combine_count_tables(musica = dbs_musica, to_comb = c("SBS96", "DBS"), 
                     name = "sbs_dbs", description = "An example combined 
                     table, combining SBS96 and DBS", overwrite = TRUE)
```

* Combined - Any number of tables can be combined to create more complex 
motifs, but can lead to double-counting. 

```{r}
annotate_transcript_strand(musica, "19", build_table = FALSE)
build_custom_table(musica = musica, variant_annotation = "Transcript_Strand", 
                   name = "Transcript_Strand", 
                   description = "A table of transcript strand of variants", 
                   data_factor = c("T", "U"), overwrite = TRUE)
```

* Custom - Custom tables can be created from any mutation-level annotation, 
which can then be used for deconvolution (or prediction assuming an 
existing set of signatures has already been discovered).

# Discover Signatures/Exposures
Discovery and prediction result are loaded into a self-contained result object 
that includes signatures and sample exposures.
```{r discover_sigs}
result <- discover_signatures(musica = musica, table_name = "SBS96", 
                              num_signatures = 3, method = "lda", nstart = 10)
```

Supported deconvolution algorithms:

* Non-negative matrix factorization (NMF)
* Latent Dirichlet Allocation (LDA)

Both have built-in `seed` capabilities for reproducible results, `nstarts` for 
multiple independant chains from which the best final result will be chosen. 
NMF also allows for parallel processing via `par_cores`.

# Plotting

## Signatures
```{r, plot_sigs}
plot_signatures(result)
```

Signatures can be named based on prior knowledge and displayed in the plots:

```{r, name_sigs}
name_signatures(result, c("Smoking", "APOBEC", "UV"))
plot_signatures(result)
```

## Exposures
**Exposures** are defined as the estimated amount of each signature in each tumor. Barplots showing the exposures in each sample can be plotted:
```{r exposures_raw}
plot_exposures(result, plot_type = "bar")
```

The proportion of each exposure in each tumor can be shown by setting `proprotional = TRUE`:
```{r exposures_prop}
plot_exposures(result, plot_type = "bar", proportional = TRUE)
```

Counts for individual samples can also be plotted:

```{r sample_counts}
samples <- sample_names(musica)
plot_sample_counts(musica, sample_names = samples[c(3,4,5)], table_name = "SBS96")
```

## Comparison to external signatures (e.g. COSMIC)
Compare to COSMIC signatures by leaving the second result as default

Compare functions `compare_results(), compare_cosmic_v2(), compare_cosmic_v3()` 
can use either cosine correlation or jensen-shannon divergence as distance 
metrics using `metric = c("cosine", "jsd")` and the threshold for finding 
matching signatures can be lowered by setting `threshold` below `0.9`.

```{r compare_cosmic}
compare_cosmic_v2(result, threshold = 0.75)
```

# Predicting exposures using existing signatures
We can list which signatures are present in each tumor type according to the [COSMIC V2 database](https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt). Here we find which signatures are present in lung cancer:
```{r subtype_map}
cosmic_v2_subtype_map("lung")
```

Exposures for a subset of COSMIC signatures in our current dataset:

```{r predict_cosmic}
data("cosmic_v2_sigs")
pred_cosmic <- predict_exposure(musica = musica, table_name = "SBS96",
                               signature_res = cosmic_v2_sigs,
                               signatures_to_use =  c(1, 4, 7, 13),
                               algorithm = "lda")

plot_signatures(pred_cosmic)
plot_exposures(pred_cosmic, plot_type = "bar")
```

Note that if `signatures_to_use` is not supplied by the user, then exposures for all signatures in the result object will be estimated. We can predict exposures from any result object. For example, we can predict using the result object containing the discovered signatures:

```{r predict_previous}
pred_our_sigs <- predict_exposure(musica = musica, table_name = "SBS96",
                                 signature_res = result, algorithm = "lda")

```

Different signatures in different result objects can also be compared to each other:

```{r predict_compare}
compare_results(result = pred_cosmic, other_result = pred_our_sigs, 
                threshold = 0.60)
```

# Use of sample annotations for advanced sample comparisons
## Adding annotations
```{r annotations}
annot <- read.table(system.file("extdata", "sample_annotations.txt", 
                                package = "musicatk"), sep = "\t", header=TRUE)
samp_annot(result, "Tumor_Subtypes") <- annot$Tumor_Subtypes
```

## Standard discovery using musicatk with sample annotations

`plot_exposures` plots sample exposures to signatures in a result object. It 
can operate in several modes, organizing by an annotation or by signatures 
`group_by = c("annotation", "signature")` or all samples together 
`group_by = NULL`. Samples can be sorted by name or by total counts 
`sort_samples = "c("name", "total")` or by a specific signature (e.g. 
`sort_samples = "c("Signature1")`). Samples can be combined by annotation using 
`plot_type = "box"` to create cohort-level comparison plots.


`plot_type = c("bar", box")`

```{r plot_annotations}
plot_exposures(result, plot_type = "bar", group_by = "annotation", 
               annotation = "Tumor_Subtypes")
plot_exposures(result, plot_type = "box", proportion = TRUE, 
               group_by = "annotation", annotation = "Tumor_Subtypes")
plot_exposures(result, plot_type = "box", group_by = "signature", 
               color_by = "annotation", annotation = "Tumor_Subtypes")
```

## Creation and plotting of Uniform Manifold Approximation and Projection (UMAP)

`create_umap` creates a umap matrix using standard umap parameters, 
`n_neighbors`, `min_dist`, and `spread`

`plot_umap` plots the created umaps either by signatures 
`color_by = signature` or by annotation `color_by = "annot"` with a 
specified annotation (e.g. `annotation = "Tumor_Subtypes"`)

```{r umap}
create_umap(result = result)
plot_umap(result = result)
plot_umap(result = result, color_by = "annotation", 
          annotation = "Tumor_Subtypes", add_annotation_labels = TRUE)
```


# Use of Plotly in plotting

plot_signatures, plot_exposures, and plot_umap, all have builty in ggplotly 
capabilities. Simply specifying `plotly = TRUE` enables interactive plots 
that allows examination of individuals sections, zooming and resizing, and 
turning on and off annotation types and legend values.

```{r plotly}
plot_signatures(result, plotly = TRUE)
plot_exposures(result, plotly = TRUE)
plot_umap(result, plotly = TRUE)
```

# Note on reproducibility

Several functions make use of stochastic algorithms or procedures which 
require the use of random number generator (RNG) for simulation or sampling. 
To maintain reproducibility, all these functions should be called using 
```withr::with_seed(seed, function())``` make sure same results are generated 
each time one of these functions is called. Using with_seed for reproducibility 
is important for several functions including *discover_signatures*, 
*predict_exposure*, and *create_umap*.

```{r reproducible_prediction}
seed <- 1
reproducible_prediction <- withr::with_seed(seed, 
                                            predict_exposure(musica = musica, 
                                                         table_name = "SBS96",
                                 signature_res = result, algorithm = "lda"))
```


# Session Information
```{r session}
sessionInfo()
```
